# **Lesta Test Task**

### Задание №1

#### Условие:
##### На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

#### Пример: 
```python
def isEven(value):
  return value % 2 == 0
```

#### [Мое решение](first_task/main.py)

##### Плюс моей реализации функции определения четности: более высокая скорость на больших числах, потому что не надо все число делить с остатком на 2, а достаточно лишь рассмотреть последнюю цифру

##### Минус моей реализации функции определения четности: менее интуитивно-понятный код для других разработчиков

##### Плюс реализации из примера: как раз простота и понятность кода

##### Минус реализации из примера: функция при больших числах будет работать медленно

### Задание №2

#### Условие:
##### На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

#### [Мое решение](second_task/main.py)

##### В этом задании я сделал два циклических буфера FIFO:
1. С помощью list-а
2. С помощью ноды односвязанного списка

##### Плюс первой реализации: я протестировал скорость работы обеих реализаций и оказалось, что этот вариант оказался быстрее по времени, в ней достаточно поменять элемент под индексом списка и нет затрат на привязку нод друг с другом, как во второй реализации

##### Минус первой реализации: мы затрачиваем O(N) места для хранения элементов, даже если у нас в данный момент времени в буфере меньше N элементов

##### Плюс второй реализации: более понятный код для разработчиков, знакомых со структорами данных, 

##### Минус второй реализации: чуть более медленно работает по сравнению с первым вариантом

##### Хочу отметить, что похожую задачу я решал на [Leetcode](https://leetcode.com/problems/design-circular-queue/description/), где мое решение было лучше 90% остальных
