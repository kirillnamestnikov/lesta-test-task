# **Lesta Test Task**

## Наместников Кирилл

### Задание №1

#### Условие:
##### На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

#### Пример: 
```python
def isEven(value):
  return value % 2 == 0
```

#### [Мое решение](first_task/main.py)

#### Плюс моей реализации функции определения четности: более высокая скорость на больших числах, потому что не надо все число делить с остатком на 2, а достаточно лишь рассмотреть последнюю цифру.

#### Минус моей реализации функции определения четности: менее интуитивно-понятный код для других разработчиков.

#### Плюс реализации из примера: как раз простота и понятность кода.

#### Минус реализации из примера: функция при больших числах будет работать медленно.

### Задание №2

#### Условие:
##### На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

#### [Мое решение](second_task/main.py)

#### В этом задании я сделал два циклических буфера FIFO:
1. С помощью list-а
2. С помощью ноды односвязанного списка

#### Плюс первой реализации: я протестировал скорость работы обеих реализаций и оказалось, что этот вариант оказался быстрее по времени, в ней достаточно поменять элемент под индексом списка и нет затрат на привязку нод друг с другом, как во второй реализации.

#### Минус первой реализации: мы затрачиваем O(N) места для хранения элементов, даже если у нас в данный момент времени в буфере меньше N элементов.

#### Плюс второй реализации: более понятный код для разработчиков, знакомых со структорами данных.

#### Минус второй реализации: чуть более медленно работает по сравнению с первым вариантом.

#### Хочу отметить, что похожую задачу я решал на [Leetcode](https://leetcode.com/problems/design-circular-queue/description/), где мое решение было лучше 90% остальных.

### Задание №3

#### Условие:
##### На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.

#### [Мое решение](third_task/main.py)

#### В этом задании я реализовал алгоритм сортировки Merge Sort, который в лучшем, среднем и даже плохом случае работает за O(NlogN), к тому же этот алгоритм является устойчивым, поэтому мы не потеряем относительный порядок элементов.

#### К минусам можно отнести тот факт, что этому алгоритму нужна дополнительная память для временного хранения данных O(N).

#### Также я рассматривал для реализации Timsort, который используется под капотом у Python и Quicksort. Первый вариант я не взял, потому что он не особо оптимален для маленьких массивов, а второй в худшем случае работает за O(N^2).
